<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root {
            --particle-color: rgba(255,255,255,0.8);
            --line-color: rgba(255,255,255,0.2);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #0a0e17;
            touch-action: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
        }

        .content {
            position: relative;
            z-index: 2;
            /* 保持原有内容样式 */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="content">
        <!-- 保持原有链接内容 -->
    </div>

    <script>
        class ParticleNetwork {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.touchPoints = new Map();
                this.noiseSeed = Math.random() * 1000;

                this.init();
                this.bindEvents();
                this.animate();
            }

            init() {
                this.resize();
                this.createParticles();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            createParticles() {
                const density = window.innerWidth < 768 ? 120 : 80;
                const count = Math.floor((this.width * this.height) / density ** 2);
                
                for(let i = 0; i < count; i++) {
                    this.particles.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        radius: Math.random() * 1.5 + 0.5,
                        baseRadius: 0,
                        opacity: Math.random() * 0.5 + 0.3
                    });
                }
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());
                
                // 触屏事件
                this.canvas.addEventListener('touchstart', e => this.handleTouch(e));
                this.canvas.addEventListener('touchmove', e => this.handleTouch(e));
                this.canvas.addEventListener('touchend', () => this.touchPoints.clear());
            }

            handleTouch(e) {
                e.preventDefault();
                this.touchPoints.clear();
                const touches = e.touches;
                for(let i = 0; i < touches.length; i++) {
                    this.touchPoints.set(i, {
                        x: touches[i].clientX,
                        y: touches[i].clientY,
                        radius: 80
                    });
                }
            }

            applyNoise(p) {
                // 柏林噪声生成自然运动
                const scale = 0.005;
                const speed = 0.8;
                const noise = (x, y) => {
                    return Math.perlin2(x + this.noiseSeed, y + this.noiseSeed) * speed;
                };
                
                p.vx += noise(p.x * scale, p.y * scale) * 0.1;
                p.vy += noise(p.y * scale, p.x * scale) * 0.1;
            }

            updateParticles() {
                this.particles.forEach(p => {
                    // 自然运动
                    this.applyNoise(p);
                    
                    // 边界反弹
                    if(p.x < 0 || p.x > this.width) p.vx *= -0.8;
                    if(p.y < 0 || p.y > this.height) p.vy *= -0.8;
                    
                    // 速度衰减
                    p.vx *= 0.99;
                    p.vy *= 0.99;
                    
                    // 更新位置
                    p.x += p.vx;
                    p.y += p.vy;

                    // 触屏避让
                    this.touchPoints.forEach(tp => {
                        const dx = p.x - tp.x;
                        const dy = p.y - tp.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if(dist < tp.radius) {
                            const force = (tp.radius - dist) / tp.radius;
                            p.vx += (dx / dist) * force * 0.3;
                            p.vy += (dy / dist) * force * 0.3;
                        }
                    });
                });
            }

            drawParticles() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // 绘制连线
                this.particles.forEach((p1, i) => {
                    this.particles.slice(i + 1).forEach(p2 => {
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if(dist < 100) {
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = `rgba(255,255,255,${0.3 - dist/100})`;
                            this.ctx.lineWidth = 0.3;
                            this.ctx.moveTo(p1.x, p1.y);
                            this.ctx.lineTo(p2.x, p2.y);
                            this.ctx.stroke();
                        }
                    });
                });

                // 绘制粒子
                this.particles.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255,255,255,${p.opacity})`;
                    this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            animate() {
                this.updateParticles();
                this.drawParticles();
                this.noiseSeed += 0.005;
                requestAnimationFrame(() => this.animate());
            }
        }

        // 初始化网络
        Math.seedrandom();
        if(typeof Math.perlin2 === 'undefined') {
            // 柏林噪声polyfill
            // (此处需添加perlin噪声生成代码，因篇幅限制暂略)
        }
        new ParticleNetwork();
    </script>
</body>
</html>